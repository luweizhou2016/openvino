// Copyright (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
//

//# CM kernel for flash attn, reference
#include <cm/cm.h>
#include <cm/cmtl.h>

//# CM-compiler is C++17
static_assert(__cplusplus >= 201703L);

extern "C" _GENX_MAIN_ void KERNEL_NAME(int seqlen, int seq_blk, half* k_ptr [[type("svmptr_t")]], half* kmean_ptr [[type("svmptr_t")]]) {

    // q [B, L, H, S]
    auto kvhead = cm_group_id(0);
    auto sblk_idx = cm_group_id(1);
    auto lid = cm_linear_local_id();
    auto seq_start = lid * seq_blk;

    auto threads_cnt = (seqlen + seq_blk - 1) / seq_blk;
#if CMFLA_QK_FUSED
    uint constexpr TOTAL_HEADS = (CMFLA_NUM_KV_HEADS+CMFLA_NUM_KV_HEADS+CMFLA_NUM_HEADS);
    auto offset = ((seq_start *TOTAL_HEADS  + kvhead + CMFLA_NUM_HEADS)*CMFLA_HEAD_SIZE + sblk_idx*CMKMEAN_STATE_BLK);
    //don't know why, when lowering down pitch can achive 385.64 GB/S, just a test.
    //TLB issue?
    //auto pitch = (TOTAL_HEADS-1)*HEAD_SZ;
    auto pitch = TOTAL_HEADS*CMFLA_HEAD_SIZE;
#else
    auto offset = ((seq_start *CMFLA_NUM_KV_HEADS  + kvhead)*CMFLA_HEAD_SIZE + sblk_idx*CMKMEAN_STATE_BLK);
    k_ptr += offset;
    auto pitch = CMFLA_NUM_KV_HEADS*CMFLA_HEAD_SIZE;
#endif
    constexpr uint BUF_SIZE = CMKMEAN_LOCAL_SZ*CMKMEAN_STATE_BLK*sizeof(float);
    cm_slm_init(BUF_SIZE);
    auto scratch_buf = cm_slm_alloc(BUF_SIZE);

    vector <half, CMKMEAN_STATE_BLK> seq;
    vector <float, CMKMEAN_STATE_BLK> seq_f32;
    vector<float, CMKMEAN_STATE_BLK> seq_blk_sum = 0;


    if (seq_start < seqlen) {
        auto remaing_seq = (seq_start + seq_blk ) > seqlen ?  (seqlen-seq_start): seq_blk;

        if (seq_blk == remaing_seq) {
            #pragma unroll(CMKMEAN_UNROLL_NUM)
            for (int i = 0; i < seq_blk; i++) {
                cm_svm_block_read(reinterpret_cast<svmptr_t>(k_ptr), seq);
                seq_f32 = seq;
                seq_blk_sum += seq_f32;
                k_ptr += pitch;
            }
        } else {
            for (int i = 0; i < remaing_seq; i++) {
                cm_svm_block_read(reinterpret_cast<svmptr_t>(k_ptr), seq);
                seq_f32 = seq;
                seq_blk_sum += seq_f32;
                k_ptr += pitch;
            }
        }
        cm_slm_block_write(scratch_buf, lid*CMKMEAN_STATE_BLK*sizeof(float), seq_blk_sum.format<float>());
    }
    cm_barrier();
    if (lid == 0) {
        seq_blk_sum = 0;
        vector<float, CMKMEAN_STATE_BLK> tmpsum = 0;
        int off = 0;
        for (int r = 0; r<threads_cnt; r++, off +=CMKMEAN_STATE_BLK*sizeof(float)) {
            cm_slm_block_read(scratch_buf, GENX_NONE, off, tmpsum.format<float>());
            seq_blk_sum += tmpsum;
        }
        vector<half, CMKMEAN_STATE_BLK> kmean;
        kmean = seq_blk_sum / (float)(seqlen);
        cm_svm_block_write(reinterpret_cast<svmptr_t>(kmean_ptr + kvhead*CMFLA_HEAD_SIZE+sblk_idx*CMKMEAN_STATE_BLK), kmean);
    }
}

